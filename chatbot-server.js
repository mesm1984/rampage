require('dotenv').config({ path: '.env' });
const express = require('express');
const cors = require('cors');
const path = require('path');
const http = require('http');
const fetch = require('node-fetch');

// Configuration initiale
const PORT = process.env.PORT || 3000; // Port par d√©faut 3000
// Suppression Hugging Face : plus de cl√©, mod√®le ou endpoint distant

// Cr√©ation de l'application Express
console.log('=== Configuration du serveur ===');
console.log('Port:', PORT);
console.log('Environnement:', process.env.NODE_ENV || 'development');


console.log('\nCr√©ation de l\'application Express...');
const app = express();

// Configuration du middleware
console.log('Configuration du middleware...');

// Configuration CORS plus s√©curis√©e
const corsOptions = {
    origin: function (origin, callback) {
        // Autoriser toutes les origines en d√©veloppement
        if (!origin || process.env.NODE_ENV !== 'production') {
            return callback(null, true);
        }
        
        // En production, autoriser uniquement les domaines sp√©cifi√©s
        const allowedOrigins = [
            'https://votredomaine.com',
            'http://localhost:3000',
            'http://127.0.0.1:3000',
            'http://localhost:5500',
            'http://127.0.0.1:5500'
        ];
        
        if (allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    optionsSuccessStatus: 200 // Pour les navigateurs qui ne supportent pas 204
};

app.use(cors(corsOptions));

// Gestion des requ√™tes OPTIONS pour CORS preflight
app.options('*', cors(corsOptions));

// Middleware pour le parsing du JSON
app.use(express.json());

// Servir les fichiers statiques
app.use(express.static('.'));

// Middleware pour ajouter des en-t√™tes de s√©curit√©
app.use((req, res, next) => {
    // Prot√®ge contre les attaques XSS
    res.setHeader('X-Content-Type-Options', 'nosniff');
    // Emp√™che le chargement de la page dans une iframe
    res.setHeader('X-Frame-Options', 'DENY');
    // Active la politique de s√©curit√© du contenu (CSP)
    res.setHeader('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; font-src 'self' https://cdnjs.cloudflare.com; img-src 'self' data:;");
    // Active le mode strict pour les cookies
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    next();
});

// Configuration des routes
console.log('Configuration des routes...');



// Charger les FAQs depuis le fichier JSON
let faqs = [];
try {
    console.log('Chargement du fichier FAQ...');
    const faqsData = require('./data/faqs.json');
    
    // V√©rifier la structure des donn√©es
    if (!faqsData || !Array.isArray(faqsData.categories)) {
        throw new Error('Format de fichier FAQ invalide: categories manquantes');
    }
    
    // Extraire et aplatir toutes les questions
    faqs = faqsData.categories.flatMap(category => {
        if (!category.questions || !Array.isArray(category.questions)) {
            console.warn(`Cat√©gorie sans questions: ${category.name || 'sans nom'}`);
            return [];
        }
        return category.questions.map(q => ({
            question: q.question,
            answer: q.reponse || q.answer, // G√©rer les deux formats
            category: category.name
        }));
    });
    
    console.log(`${faqs.length} questions/r√©ponses charg√©es depuis ${faqsData.categories.length} cat√©gories`);
    
    // Afficher un √©chantillon pour v√©rification
    if (faqs.length > 0) {
        console.log('Exemple de question charg√©e:', {
            question: faqs[0].question.substring(0, 50) + '...',
            category: faqs[0].category
        });
    }
    
} catch (error) {
    console.error('Erreur lors du chargement des FAQs:', error.message);
    console.error('Stack:', error.stack);
}

// Fonction pour trouver une r√©ponse dans les FAQs
function findInFAQs(question) {
    console.log('\nüîç Recherche dans les FAQs pour:', question);
    
    if (!faqs || !faqs.length) {
        console.log('Aucune FAQ charg√©e ou tableau vide');
        return null;
    }
    
    const lowerQuestion = question.toLowerCase().trim();
    console.log('Question normalis√©e:', lowerQuestion);
    
    // 1. V√©rifier les correspondances exactes
    const exactMatch = faqs.find(qa => {
        const qLower = qa.question.toLowerCase().trim();
        const match = qLower === lowerQuestion;
        if (match) console.log('Correspondance exacte trouv√©e:', qa.question);
        return match;
    });
    
    if (exactMatch) return exactMatch.answer;
    
    // 2. V√©rifier si la question contient une question de la FAQ
    const partialMatch = faqs.find(qa => {
        const qLower = qa.question.toLowerCase();
        const match = lowerQuestion.includes(qLower) || qLower.includes(lowerQuestion);
        if (match) console.log('Correspondance partielle trouv√©e:', qa.question);
        return match;
    });
    
    if (partialMatch) return partialMatch.answer;
    
    // 3. V√©rifier les mots-cl√©s
    console.log('Recherche par mots-cl√©s...');
    const keywords = lowerQuestion.split(/\s+/).filter(k => k.length > 2); // Ignorer les mots trop courts
    console.log('Mots-cl√©s extraits:', keywords);
    
    const matches = [];
    
    for (const qa of faqs) {
        const qLower = qa.question.toLowerCase();
        const qaKeywords = qLower.split(/\s+/);
        
        const matchCount = keywords.filter(keyword => 
            qaKeywords.some(qaKw => qaKw.includes(keyword) || keyword.includes(qaKw))
        ).length;
        
        const matchRatio = matchCount / keywords.length;
        console.log(`Question: "${qa.question}" - Correspondance: ${matchCount}/${keywords.length} (${Math.round(matchRatio*100)}%)`);
        
        if (matchCount >= Math.min(2, keywords.length) || matchRatio > 0.5) {
            matches.push({ qa, score: matchCount });
        }
    }
    
    if (matches.length > 0) {
        // Trier par score d√©croissant
        matches.sort((a, b) => b.score - a.score);
        console.log('Meilleure correspondance trouv√©e:', matches[0].qa.question);
        return matches[0].qa.answer;
    }
    
    console.log('Aucune correspondance trouv√©e dans les FAQs');
    return null;
}

// Route pour r√©cup√©rer les cat√©gories de FAQ
app.get('/api/faqs', (req, res) => {
    try {
        const faqsData = require('./data/faqs.json');
        if (!faqsData || !Array.isArray(faqsData.categories)) {
            return res.status(500).json({ error: 'Format de fichier FAQ invalide' });
        }
        
        // Ne renvoyer que les informations n√©cessaires pour les cat√©gories
        const categories = faqsData.categories.map(category => ({
            id: category.id,
            name: category.name,
            description: category.description || ''
        }));
        
        res.json({ categories });
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des cat√©gories:', error);
        res.status(500).json({ error: 'Erreur serveur lors du chargement des cat√©gories' });
    }
});

// Route pour r√©cup√©rer les questions d'une cat√©gorie sp√©cifique
app.get('/api/faqs/:categoryId', (req, res) => {
    try {
        const { categoryId } = req.params;
        const faqsData = require('./data/faqs.json');
        
        if (!faqsData || !Array.isArray(faqsData.categories)) {
            return res.status(500).json({ error: 'Format de fichier FAQ invalide' });
        }
        
        // Trouver la cat√©gorie demand√©e
        const category = faqsData.categories.find(cat => cat.id === categoryId);
        
        if (!category) {
            return res.status(404).json({ error: 'Cat√©gorie non trouv√©e' });
        }
        
        // Renvoyer les questions de la cat√©gorie
        res.json({
            id: category.id,
            name: category.name,
            description: category.description || '',
            questions: category.questions || []
        });
        
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des questions:', error);
        res.status(500).json({ error: 'Erreur serveur lors du chargement des questions' });
    }
});

// Route pour l'API de chat
app.post('/api/chat', async (req, res) => {
    console.log('\n=== NOUVELLE REQU√äTE API ===');
    console.log('Headers:', JSON.stringify(req.headers, null, 2));
    console.log('Corps de la requ√™te:', JSON.stringify(req.body, null, 2));
    
    try {
        const { question, context = '' } = req.body;
        
        if (!question) {
            console.log('‚ùå Erreur: Aucune question fournie');
            return res.status(400).json({ error: 'La question est requise' });
        }

        console.log('Question re√ßue:', question);
        
        // V√©rifier d'abord dans les FAQs
        console.log('\nüîç Recherche dans les FAQs...');
        const faqAnswer = findInFAQs(question);
        if (faqAnswer) {
            console.log('‚úÖ R√©ponse trouv√©e dans les FAQs');
            console.log('Question:', question);
            console.log('R√©ponse:', faqAnswer);
            return res.json([{ generated_text: faqAnswer }]);
        } else {
            console.log('‚ÑπÔ∏è Aucune correspondance dans les FAQs');
        }
        
        // V√©rifier si c'est une question simple qui peut √™tre g√©r√©e localement
        const simpleResponses = {
            'salut': 'Bonjour ! Comment puis-je vous aider avec le VTT Freeride aujourd\'hui ?',
            'bonjour': 'Bonjour ! Pr√™t pour une aventure en VTT ?',
            'au revoir': '√Ä bient√¥t ! N\'h√©sitez pas √† revenir pour plus d\'infos sur le VTT !',
            'merci': 'Je vous en prie ! Avez-vous d\'autres questions sur le VTT ?',
            'aide': 'Je peux vous aider avec des questions sur le VTT, les comp√©titions, les techniques, etc. Posez-moi votre question !',
            'red bull rampage': 'Le Red Bull Rampage est une comp√©tition de VTT de descente extr√™me qui se d√©roule dans le d√©sert de l\'Utah.',
            'quand est le red bull rampage': 'Le Red Bull Rampage a g√©n√©ralement lieu en octobre. La date exacte pour 2025 sera annonc√©e prochainement.'
        };

        const lowerQuestion = question.toLowerCase();
        if (simpleResponses[lowerQuestion]) {
            console.log('R√©ponse simple trouv√©e');
            return res.json([{ generated_text: simpleResponses[lowerQuestion] }]);
        }
        

        // Si aucune r√©ponse FAQ ou simple, r√©ponse par d√©faut
        res.json([{ 
            generated_text: 'Je ne suis pas s√ªr de comprendre. Pourriez-vous reformuler votre question sur le VTT Freeride ?' 
        }]);
        
    } catch (error) {
        console.error('\n=== ERREUR DANS LA ROUTE /API/CHAT ===');
        console.error('Message d\'erreur:', error.message);
        console.error('Stack trace:', error.stack);
        
        // Journalisation plus d√©taill√©e pour le d√©bogage
        if (error.response) {
            console.error('R√©ponse d\'erreur:', {
                status: error.response.status,
                headers: error.response.headers,
                data: error.response.data
            });
        }
        
        res.status(500).json({ 
            error: 'D√©sol√©, une erreur est survenue lors du traitement de votre question.',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
});

// Toutes les autres routes renvoient vers index.html
app.get('*', (req, res) => {
    console.log('Requ√™te sur route non g√©r√©e:', req.path);
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Cr√©ation du serveur HTTP
console.log('Cr√©ation du serveur HTTP...');
const server = http.createServer(app);

// Gestion des erreurs du serveur
server.on('error', (error) => {
    console.error('Erreur du serveur:', error);
    if (error.code === 'EADDRINUSE') {
        console.error(`Le port ${PORT} est d√©j√† utilis√©`);
    }
    process.exit(1);
});

// D√©marrer l'√©coute
console.log('D√©marrage de l\'√©coute sur le port', PORT, '...');
server.listen(PORT, '0.0.0.0', () => {
    console.log('\n=== Serveur d√©marr√© avec succ√®s ===');
    console.log(`URL: http://localhost:${PORT}`);
    console.log('Environnement:', process.env.NODE_ENV || 'development');

    console.log('\nAppuyez sur Ctrl+C pour arr√™ter le serveur\n');
    
    // V√©rifier que le serveur est toujours en cours d'ex√©cution
    setInterval(() => {
        console.log('[HEARTBEAT] Le serveur est toujours en cours d\'ex√©cution...');
    }, 5000);
});

// Gestion de l'arr√™t propre
process.on('SIGINT', () => {
    console.log('\nArr√™t du serveur...');
    server.close(() => {
        console.log('Serveur arr√™t√©.');
        process.exit(0);
    });
});

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
    console.error('ERREUR NON G√âR√âE:', error);
    if (server && server.close) {
        server.close(() => process.exit(1));
    } else {
        process.exit(1);
    }
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('REJET NON G√âR√â:', reason);    
    if (server && server.close) {
        server.close(() => process.exit(1));
    } else {
        process.exit(1);
    }
});
